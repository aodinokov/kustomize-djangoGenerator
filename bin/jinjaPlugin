#!/usr/bin/python3

import logging
import os
import base64
import sys
import copy
import yaml
from collections import OrderedDict
from jinja2 import Environment
from functools import reduce
import operator

# yaml-helpers: to avoid reordering of fields when read yaml, we need to use OrderedDict
# see
# https://github.com/yaml/pyyaml/issues/110 and
# https://stackoverflow.com/questions/5121931/in-python-how-can-you-load-yaml-mappings-as-ordereddicts
def yaml_orderedLoad(arg, _all=False, Loader=yaml.Loader, object_pairs_hook=OrderedDict):
    class OrderedLoader(Loader):
        pass
    def construct_mapping(loader, node):
        loader.flatten_mapping(node)
        return object_pairs_hook(loader.construct_pairs(node))
    OrderedLoader.add_constructor(
        yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG,
        construct_mapping)
    if _all:
        return yaml.load_all(arg, OrderedLoader)
    return yaml.load(arg, OrderedLoader)

def yaml_orderedDump(data, stream=None, Dumper=yaml.Dumper, **kwds):
    class OrderedDumper(Dumper):
        pass
    def _dict_representer(dumper, data):
        return dumper.represent_mapping(
            yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG,
            data.items())
    OrderedDumper.add_representer(OrderedDict, _dict_representer)
    return yaml.dump(data, stream, OrderedDumper, **kwds)

# symmetric-encryption-helper: the basic functionality to decrypt/encrypt configential data
# see https://nitratine.net/blog/post/encryption-and-decryption-in-python/#what-is-symmetric-encryption
def crypt_getKeyFromPassword(password_provided):
    from cryptography.hazmat.backends import default_backend
    from cryptography.hazmat.primitives import hashes
    from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

    password = password_provided.encode() # Convert to type bytes
    salt = b'salt_' # CHANGE THIS - recommend using a key from os.urandom(16), must be of type bytes
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=salt,
        iterations=100000,
        backend=default_backend()
    )
    return base64.urlsafe_b64encode(kdf.derive(password))

def crypt_getKey():
    return crypt_getKeyFromPassword(os.environ['JINJA_CRYPT_PASSWORD'])

# functions for globals TODO: move thems to separate modules
def yaml_load(y):
    logger.debug("yaml_load y={}\n".format(str(y)))
    return yaml_orderedLoad(y)

def yaml_dump(y):
    logger.debug("yaml_dump y={}\n".format(str(y)))
    return yaml_orderedDump(y, default_flow_style=False)

def yaml_dumpAll(a):
    logger.debug("yaml_dumpAll a={}\n".format(str(a)))
    result = ''
    for y in a:
        result+=yaml_orderedDump(y, default_flow_style=False)
        result+='---\n'
    return result

def crypt_encrypt(s):
    from cryptography.fernet import Fernet
    f = Fernet(crypt_getKey())
    return base64.b64encode(f.encrypt(s.encode())).decode()

def crypt_decrypt(e):
    from cryptography.fernet import Fernet
    f = Fernet(crypt_getKey())
    return f.decrypt(base64.b64decode(e.encode())).decode()

# vault-helper:
# see more https://www.vaultproject.io/docs/commands/
# https://github.com/hvac/hvac 
# and https://hvac.readthedocs.io/en/stable/overview.html#getting-started
def vault_getClient():
    import hvac
    # TODO: read some extended params from file if needed (in home dir or provided via env)
    return hvac.Client(url = os.environ['VAULT_ADDR'],
            token=os.environ['VAULT_TOKEN'])

# taken from https://stackoverflow.com/questions/14692690/access-nested-dictionary-items-via-a-list-of-keys
# can also use https://pypi.org/project/dpath/ 
def _dict_getByPath(dataDict, path):
    mapList = [int(i) if i.isdigit() else i for i in path.split('/')]
    try:
        return reduce(operator.getitem, mapList, dataDict)
    except:
        #TODO: catch only corrent exceptions
        logger.error("filter_fieldExits error: {}\n".format(str(sys.exc_info()[0])))
    return None

def dict_getByPath(dataDict, path):
    logger.debug("dict_getByPath dataDict={} path={}\n".format(str(dataDict), str(path)))
    return _dict_getByPath(dataDict, path)
        
def dict_setByPath(dataDict, path, value):
    logger.debug("dict_setByPath dataDict={} path={} value={}\n".format(str(dataDict), str(path), str(value)))
    mapList = [int(i) if i.isdigit() else i for i in path.split('/')]
    dataDict_copy = copy.deepcopy(dataDict)
    reduce(operator.getitem, mapList[:-1], dataDict_copy)[mapList[-1]] = value
    logger.debug("dict_setByPath dataDict_copy={}\n".format(str(dataDict_copy)))
    return dataDict_copy

def dict_update(dataDict1, dataDict2):
    logger.debug("dict_update dataDict1={} dataDict2={}\n".format(str(dataDict1), str(dataDict2)))
    dataDict1_copy = copy.deepcopy(dataDict1)
    dataDict1_copy.update(dataDict2)
    return dataDict1_copy

def filter_fieldExist(path):
    logger.debug("filter_fieldExist path={}\n".format(str(path)))
    def filter(dataDict):
        logger.debug("fieldExist path={} dataDict={}\n".format(str(path), str(dataDict)))
        result = not _dict_getByPath(dataDict, path) is None
        logger.debug("fieldExist result={}\n".format(str(result)))
        return result
    return filter
        
def filter_fieldEqual(path, val):
    logger.debug("filter_fieldEqual path={} val={}\n".format(str(path), str(val)))
    def filter(dataDict):
        logger.debug("fieldEqual path={} dataDict={} val={}\n".format(str(path), str(dataDict), str(val)))
        # TODO: compare only leafs
        result = False
        if _dict_getByPath(dataDict, path) == val:
            result = True
        logger.debug("fieldEqual result={}\n".format(str(result)))
        return result
    return filter

def filter_operatorNot(filterToInvert):
    def filter(dataDict):
        return not filterToInvert(dataDict)
    return filter

def filter_operatorAnd(*args):
    if len(args) < 2:
        raise ValueError('filter_operatorAnd needs at least 2 arguments')

    def filter(dataDict):
        for i in args:
            if not i(dataDict):
                return False
        return True
    return filter

def filter_operatorOr(*args):
    if len(args) < 2:
        raise ValueError('filter_operatorOr needs at least 2 arguments')

    def filter(dataDict):
        for i in args:
            if i(dataDict):
                return True
        return False
    return filter

def filter_getMatchingIndexes(dataDictArray, filterToApply):
    result = []
    for i in range(len(dataDictArray)):
        if filterToApply(dataDictArray[i]):
            result.append(i)

    logger.debug("filter_getMatchingIndexes result={}\n".format(str(result)))

    return result

def get_functions():
    return {
        'yaml_load': yaml_load,
        'yaml_dump': yaml_dump,
        'yaml_dumpAll': yaml_dumpAll,
        'crypt_encrypt': crypt_encrypt,
        'crypt_decrypt': crypt_decrypt,
        'dict_getByPath': dict_getByPath,
        'dict_setByPath': dict_setByPath, 
        'dict_update': dict_update, 
        'filter_fieldExist': filter_fieldExist,
        'filter_fieldEqual': filter_fieldEqual,
        'filter_operatorNot': filter_operatorNot,
        'filter_operatorAnd': filter_operatorAnd,
        'filter_operatorOr': filter_operatorOr,
        'filter_getMatchingIndexes': filter_getMatchingIndexes, }
#-------------------------------------------------------------------
def get_input():
    input = []
    for i in yaml_orderedLoad(sys.stdin, _all=True):
        input.append(i)
    return input

def render_JinjaCatalog(global_obj):

    apiVersion = global_obj["config"].get("apiVersion")
    kind = global_obj["config"].get("kind")
    data = global_obj["config"].get("data")
    parents = global_obj["config"].get("parents")
    jinjaTemplate = global_obj["config"].get("jinjaTemplate")

    if apiVersion is None or kind is None or kind != "JinjaCatalog":
        logger.debug("returning non JinjaCatalog yaml:\n{}\n".format(str(global_obj["config"])))
        return global_obj["config"]

    if jinjaTemplate is None:
        sys.exit("wasn't able to find jinjaTemplate - exiting")

    if not data is None:
        global_obj["data"] = data

    if not parents is None:
        for parent in parents:

            parent_root = parent.get('root')
            parent_jinjaCatalog = parent.get('jinjaCatalog')
            if parent_root is None:
                sys.exit("parent must contain root - exiting")

            if parent_jinjaCatalog is None:
                parent_jinjaCatalog = 'jinjacatalog.yaml'

            parent_obj = yaml_orderedLoad(get_renderred_JinjaCatalog(os.path.realpath(os.path.join(global_obj['config_root'], parent_root)), parent_jinjaCatalog))
            if parent_obj is None:
                sys.exit("couldn't read yaml - for parent {} exiting".format(str(parent)))

            parent["obj"] = parent_obj

    logger.debug("rendering with global_obj={}\n".format(str(global_obj)))

    env = Environment()
    template = env.from_string(jinjaTemplate)
    rendered = template.render(global_obj)

    logger.debug("rendered ={}\n".format(str(rendered)))

    return rendered

def get_renderred_JinjaCatalog(config_root, config_jinjaCatalog):

    global_obj = {
        'functions': get_functions(),
        'config_root': config_root}

    with open(os.path.join(config_root, config_jinjaCatalog)) as f:
        global_obj["config"] = yaml_orderedLoad(f)
    if  global_obj["config"] is None:
        sys.exit("wasn't able to read {}".format(str(config_jinjaCatalog)))

    return render_JinjaCatalog(global_obj)

def render_JinjaGenerator(global_obj):
    config_jinjaCatalog = global_obj["config"].get("jinjaCatalog")
    if config_jinjaCatalog is None:
        sys.exit("mandatory field jinjaCatalog is missed")

    config_jinjaTemplate = global_obj["config"].get("jinjaTemplate")
    if config_jinjaTemplate is None:
        sys.exit("mandatory field jinjaTemplate is missed")

    jinjaCatalog_yaml = yaml_orderedLoad(get_renderred_JinjaCatalog(global_obj['config_root'], config_jinjaCatalog))
    if jinjaCatalog_yaml is None:
        sys.exit("couldn't ready yaml")

    jinjaCatalog_yaml_kind = jinjaCatalog_yaml.get("kind")

    if jinjaCatalog_yaml_kind is None or jinjaCatalog_yaml_kind != "JinjaCatalog":
        sys.exit("resource transformed not to JinjaCatalog kind")

    global_obj["catalog"] = jinjaCatalog_yaml

    logger.debug("rendering with global_obj={}\n".format(str(global_obj)))

    env = Environment()
    template = env.from_string(config_jinjaTemplate)
    rendered =  template.render(global_obj)

    logger.debug("rendered ={}\n".format(str(rendered)))

    return rendered

def render_JinjaTransformer(global_obj):
    global_obj["resources"] = get_input()

    return render_JinjaGenerator(global_obj)

# the main configuration processing function
def process_config(config_root, config_string):
    logger.debug("process_config config_root={}, config_string:\n{}\n".format(str(config_root), str(config_string)))

    global_obj = {
        'functions': get_functions(), 
        'config_root': config_root}

    global_obj["config"] = yaml_orderedLoad(config_string)
    if global_obj["config"] is None:
        sys.exit("wasn't able to read config")
    logger.debug("config:\n{}\n".format(str(global_obj["config"])))

    config_kind = global_obj["config"].get("kind")
    if config_kind is None:
        sys.exit("config doesn't have kind field - exiting")
    logger.debug("config.kind = {}\n".format(str(config_kind)))

    if config_kind == 'JinjaGenerator':
        print(render_JinjaGenerator(global_obj))
    elif config_kind == "JinjaTransformer":
        print(render_JinjaTransformer(global_obj))
    elif config_kind == 'JinjaCatalog':
        print(render_JinjaCatalog(global_obj))

# configure logger
logger = logging.getLogger('jinjaPlugin')
logger.setLevel(logging.DEBUG)
ch = logging.StreamHandler()
if not os.environ.get('JINJA_DEBUG') is None and int(os.environ['JINJA_DEBUG']) > 0:
    ch.setLevel(logging.DEBUG)
else:
    ch.setLevel(logging.ERROR)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
ch.setFormatter(formatter)
logger.addHandler(ch)

# do the actual work
process_config(
    os.environ['KUSTOMIZE_PLUGIN_CONFIG_ROOT'],
    os.environ['KUSTOMIZE_PLUGIN_CONFIG_STRING'])

